import os
import re
import io
import zipfile
import tempfile
import base64
import logging
import warnings
import asyncio

from telethon import TelegramClient, events, Button
from telethon.errors import MessageNotModifiedError
from ebooklib import epub
from bs4 import BeautifulSoup, XMLParsedAsHTMLWarning
from PIL import Image
from lxml import etree
from docx import Document

warnings.filterwarnings("ignore", category=XMLParsedAsHTMLWarning)
logging.basicConfig(level=logging.INFO)

api_id = 24519852
api_hash = '2186f59fdf9c2ad4e7ddf0deb250ff0c'
client = TelegramClient('unified_bot', api_id, api_hash)

RESOLUTIONS = {
    '–£–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è': None,
    '64p': (64, 64),
    '144p': (256, 144),
    '360p': (640, 360),
    '480p': (854, 480),
    '720p': (1280, 720),
    '1080p': (1920, 1080)
}

user_files = {}
user_mode = {}
# –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ç–µ–∫—Å—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
last_message_text = {}

# –£–ª—É—á—à–µ–Ω–Ω–æ–µ —Ä–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ –≥–ª–∞–≤
CHAPTER_RE = re.compile(
    r"(?i)\b("
    r"–≥–ª–∞–≤–∞\s*\d+|—ç–ø–∏–∑–æ–¥\s*\d+|—á–∞—Å—Ç—å\s*\d+|–≥–ª\.\s*\d+|–æ–ø–∏—Å–∞–Ω–∏–µ\s*\d+|–∞–Ω–Ω–æ—Ç–∞—Ü–∏—è\s*\d+|"
    r"–ø—Ä–æ–ª–æ–≥|—ç–ø–∏–ª–æ–≥|–≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ|"
    r"chapter\s*\d+|episode\s*\d+|part\s*\d+|scene\s*\d+|act\s*\d+|"
    r"prologue|epilogue|foreword|afterword|preface|introduction|outro|conclusion|"
    r"\d+[-‚Äê‚Äì‚Äî]?\d*[\.\s:Ôºö)]|"
    r"\d+[ \t]*[‚Äì‚Äî-][ \t]*[^\n<:]+[:Ôºö)]|"
    r"\d+[\.\)]?[ \t]+[^\n<:Ôºö]+[:Ôºö)]|"
    r"–ø—Ä–æ–ª–æ–≥|—ç–ø–∏–ª–æ–≥|"
    r")\b"
)

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞ (—Ç–æ–ª—å–∫–æ –ø—Ä–æ—Ü–µ–Ω—Ç—ã, –±–µ–∑ —Å—á–µ—Ç—á–∏–∫–æ–≤)
def create_progress_bar(current, total, width=20):
    if total == 0:
        return "‚ñì" * width + " 100%"
    progress = int((current / total) * width)
    bar = "‚ñì" * progress + "‚ñë" * (width - progress)
    percentage = int((current / total) * 100)
    return f"{bar} {percentage}%"

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, –Ω—É–∂–Ω–æ –ª–∏ –æ–±–Ω–æ–≤–ª—è—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å (–∏–∑–±–µ–≥–∞–µ–º —Å–ø–∞–º–∞)
def should_update_progress(current, total, last_updated_percent):
    if total == 0:
        return True
    current_percent = int((current / total) * 100)
    # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –Ω–∞ 5% –∏–ª–∏ –±–æ–ª—å—à–µ
    return current_percent - last_updated_percent >= 5

# –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
async def safe_edit_message(message, new_text):
    """–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Ç–µ–∫—Å—Ç –∏–∑–º–µ–Ω–∏–ª—Å—è"""
    try:
        message_id = message.id
        if message_id not in last_message_text or last_message_text[message_id] != new_text:
            await message.edit(new_text)
            last_message_text[message_id] = new_text
    except MessageNotModifiedError:
        # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
        pass
    except Exception as e:
        logging.error(f"Error editing message: {e}")

# –ö–æ–º–∞–Ω–¥—ã
@client.on(events.NewMessage(pattern='/start'))
async def start(event):
    await event.respond(
        "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ. –í–∞—Å –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ê–¥–∏–∫–∏—è ‚Äî –±–æ—Ç –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–æ–∫—É–º–µ–Ω—Ç–∞–º–∏.\n\n"
        "–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:\n"
        "‚Ä¢ –°–∂–∞—Ç–∏–µ –∏–ª–∏ —É–¥–∞–ª–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ .epub, .fb2, .docx\n"
        "‚Ä¢ –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –≥–ª–∞–≤ –∏–∑ EPUB –∏ –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∞ —Å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –∫–æ–º–∞–Ω–¥."
    )

@client.on(events.NewMessage(pattern='/help'))
async def help_command(event):
    await event.respond(
        "–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:\n\n"
        "/start    - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º\n"
        "/help     - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n"
        "/compress - –°–∂–∞—Ç—å –∏–ª–∏ —É–¥–∞–ª–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ .epub/.fb2/.docx\n"
        "/extract  - –ò–∑–≤–ª–µ—á—å –≥–ª–∞–≤—ã –∏–∑ EPUB –∏ –ø–µ—Ä–µ—Å–æ–±—Ä–∞—Ç—å\n"
        "/cancel   - –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é\n"
    )

@client.on(events.NewMessage(pattern='/cancel'))
async def cancel(event):
    user_id = event.sender_id
    user_files.pop(user_id, None)
    user_mode.pop(user_id, None)
    await event.respond("–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.")

@client.on(events.NewMessage(pattern='/compress'))
async def compress_cmd(event):
    user_mode[event.sender_id] = 'compress'
    await event.respond("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª .epub, .fb2 –∏–ª–∏ .docx –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.")

@client.on(events.NewMessage(pattern='/extract'))
async def extract_cmd(event):
    user_mode[event.sender_id] = 'extract'
    await event.respond("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–∞–π–ª .epub, .fb2 –∏–ª–∏ .docx. –Ø –∏–∑–≤–ª–µ–∫—É –≥–ª–∞–≤—ã –∏ –ø–µ—Ä–µ—Å–æ–±–µ—Ä—É –µ–≥–æ —Å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º.")

# –ü—Ä–∏—ë–º —Ñ–∞–π–ª–æ–≤ —Å –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º
@client.on(events.NewMessage(incoming=True))
async def handle_file(event):
    if not event.file:
        return
    user_id = event.sender_id
    mode = user_mode.get(user_id)
    if not mode:
        return

    filename = event.file.name or ''
    ext = os.path.splitext(filename)[1].lower()
    file_size = event.file.size

    # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞
    progress_msg = await event.respond("üì• –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
    
    file_data = io.BytesIO()
    last_percent = 0
    
    async def progress_callback(current, total):
        nonlocal last_percent
        if total > 0 and should_update_progress(current, total, last_percent):
            progress_bar = create_progress_bar(current, total)
            new_text = f"üì• –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–∞...\n{progress_bar}"
            await safe_edit_message(progress_msg, new_text)
            last_percent = int((current / total) * 100)
    
    await client.download_media(event.message, file=file_data, progress_callback=progress_callback)
    file_data.seek(0)

    await safe_edit_message(progress_msg, "üì• –ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ñ–∞–π–ª–∞...")

    with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
        tmp.write(file_data.read())
        tmp_path = tmp.name

    user_files[user_id] = (filename, tmp_path)
    await progress_msg.delete()
    # –û—á–∏—â–∞–µ–º —Å–ª–æ–≤–∞—Ä—å –æ—Ç —É–¥–∞–ª—ë–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    last_message_text.pop(progress_msg.id, None)

    if mode == 'compress' and ext in ['.epub', '.fb2', '.docx']:
        buttons = [Button.inline(label, data=label.encode()) for label in RESOLUTIONS]
        await event.respond("–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π:", buttons=buttons)

    elif mode == 'extract' and ext in ['.epub', '.fb2', '.docx']:
        await event.respond("–§–∞–π–ª –ø–æ–ª—É—á–µ–Ω. –ù–∞—á–∏–Ω–∞—é –æ–±—Ä–∞–±–æ—Ç–∫—É...")
        try:
            if ext == '.epub':
                chapters, images = await extract_chapters_from_epub_async(tmp_path, event)
                if not chapters:
                    await event.respond("–ì–ª–∞–≤—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
                    return
                base = os.path.splitext(filename)[0]
                output_path = os.path.join(tempfile.gettempdir(), f"{base}_converted.epub")
                
                build_progress = await event.respond("üìö –°–±–æ—Ä–∫–∞ EPUB...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
                await build_epub_async(base, chapters, images, output_path, build_progress)
                await build_progress.delete()
                last_message_text.pop(build_progress.id, None)
                
                await client.send_file(user_id, output_path, caption="‚úÖ EPUB –ø–µ—Ä–µ—Å–æ–±—Ä–∞–Ω —Å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º.")
                os.remove(output_path)
                
            elif ext == '.fb2':
                chapters = await extract_chapters_from_fb2_async(tmp_path, event)
                if not chapters:
                    await event.respond("–ì–ª–∞–≤—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ FB2.")
                    return
                base = os.path.splitext(filename)[0]
                output_path = os.path.join(tempfile.gettempdir(), f"{base}_converted.fb2")
                
                build_progress = await event.respond("üìö –°–±–æ—Ä–∫–∞ FB2...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
                await build_fb2_with_toc_async(base, chapters, output_path, build_progress)
                await build_progress.delete()
                last_message_text.pop(build_progress.id, None)
                
                await client.send_file(user_id, output_path, caption="‚úÖ FB2 –ø–µ—Ä–µ—Å–æ–±—Ä–∞–Ω —Å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º.")
                os.remove(output_path)
                
            elif ext == '.docx':
                chapters = await extract_chapters_from_docx_async(tmp_path, event)
                if not chapters:
                    await event.respond("–ì–ª–∞–≤—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ DOCX.")
                    return
                base = os.path.splitext(filename)[0]
                output_path = os.path.join(tempfile.gettempdir(), f"{base}_converted.docx")
                
                build_progress = await event.respond("üìö –°–±–æ—Ä–∫–∞ DOCX...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
                await build_docx_with_toc_async(base, chapters, output_path, build_progress)
                await build_progress.delete()
                last_message_text.pop(build_progress.id, None)
                
                await client.send_file(user_id, output_path, caption="‚úÖ DOCX –ø–µ—Ä–µ—Å–æ–±—Ä–∞–Ω —Å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º.")
                os.remove(output_path)
                
        except Exception as e:
            await event.respond(f"–û—à–∏–±–∫–∞: {e}")
        finally:
            os.remove(tmp_path)
            user_mode.pop(user_id, None)
            user_files.pop(user_id, None)

# Inline-–∫–Ω–æ–ø–∫–∏
@client.on(events.CallbackQuery)
async def handle_button(event):
    user_id = event.sender_id
    mode = user_mode.get(user_id)
    if not mode:
        return

    data = event.data.decode()
    filename, filepath = user_files.get(user_id, (None, None))
    if not filename or not os.path.exists(filepath):
        await event.answer("–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.", alert=True)
        return

    ext = os.path.splitext(filename)[1].lower()

    if mode == 'compress':
        resolution = RESOLUTIONS.get(data)
        await event.edit(f"‚öôÔ∏è –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –∫ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ñ–∞–π–ª–∞ {filename}...")
        if ext == '.fb2':
            await process_fb2(event, user_id, filename, filepath, resolution)
        elif ext == '.docx':
            await process_docx(event, user_id, filename, filepath, resolution)
        elif ext == '.epub':
            await process_epub_compression(event, user_id, filename, filepath, resolution)

    os.remove(filepath)
    user_files.pop(user_id, None)
    user_mode.pop(user_id, None)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π FB2 —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º
async def process_fb2(event, user_id, filename, filepath, resolution):
    ns = {'fb2': 'http://www.gribuser.ru/xml/fictionbook/2.0'}
    tree = etree.parse(filepath)
    root = tree.getroot()
    binaries = root.xpath('//fb2:binary', namespaces=ns)

    changed = deleted = 0
    image_binaries = [b for b in binaries if 'image' in (b.get('content-type') or '')]
    total = len(image_binaries)
    
    if total == 0:
        await event.edit("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ —Ñ–∞–π–ª–µ.")
        return

    progress_msg = await event.respond(f"üñºÔ∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π FB2...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
    last_percent = 0

    for current, binary in enumerate(image_binaries, 1):
        if should_update_progress(current, total, last_percent):
            progress_bar = create_progress_bar(current, total)
            action = "–£–¥–∞–ª–µ–Ω–∏–µ" if resolution is None else "–°–∂–∞—Ç–∏–µ"
            new_text = f"üñºÔ∏è {action} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π FB2...\n{progress_bar}"
            await safe_edit_message(progress_msg, new_text)
            last_percent = int((current / total) * 100)

        if resolution is None:
            root.remove(binary)
            deleted += 1
        else:
            try:
                img = Image.open(io.BytesIO(base64.b64decode(binary.text))).convert('RGB')
                img.thumbnail(resolution, Image.Resampling.LANCZOS)
                buf = io.BytesIO()
                img.save(buf, format='JPEG', quality=30)
                binary.text = base64.b64encode(buf.getvalue()).decode()
                binary.set('content-type', 'image/jpeg')
                changed += 1
            except Exception:
                continue

    await safe_edit_message(progress_msg, "üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ñ–∞–π–ª–∞...")
    base, ext = os.path.splitext(filename)
    out_path = os.path.join(tempfile.gettempdir(), f"{base}_compressed{ext}")
    tree.write(out_path, encoding='utf-8', xml_declaration=True)
    
    await progress_msg.delete()
    last_message_text.pop(progress_msg.id, None)
    await client.send_file(user_id, out_path, caption=f"‚úÖ –ì–æ—Ç–æ–≤–æ: —Å–∂–∞—Ç–æ {changed}, —É–¥–∞–ª–µ–Ω–æ {deleted}")
    os.remove(filepath)
    os.remove(out_path)

# DOCX —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º
async def process_docx(event, user_id, filename, filepath, resolution):
    doc = Document(filepath)
    changed = deleted = 0
    total = len(doc.inline_shapes)
    
    if total == 0:
        await event.edit("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ –¥–æ–∫—É–º–µ–Ω—Ç–µ.")
        return

    progress_msg = await event.respond(f"üñºÔ∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π DOCX...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
    last_percent = 0

    if resolution is None:
        for current, shape in enumerate(doc.inline_shapes, 1):
            if should_update_progress(current, total, last_percent):
                progress_bar = create_progress_bar(current, total)
                new_text = f"üñºÔ∏è –£–¥–∞–ª–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π DOCX...\n{progress_bar}"
                await safe_edit_message(progress_msg, new_text)
                last_percent = int((current / total) * 100)
            
            try:
                shape._element.getparent().remove(shape._element)
                deleted += 1
            except Exception:
                continue
    else:
        for current, shape in enumerate(doc.inline_shapes, 1):
            if should_update_progress(current, total, last_percent):
                progress_bar = create_progress_bar(current, total)
                new_text = f"üñºÔ∏è –°–∂–∞—Ç–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π DOCX...\n{progress_bar}"
                await safe_edit_message(progress_msg, new_text)
                last_percent = int((current / total) * 100)
            
            try:
                r_id = shape._inline.graphic.graphicData.pic.blipFill.blip.embed
                img_part = doc.part.related_parts[r_id]
                img = Image.open(io.BytesIO(img_part.blob)).convert('RGB')
                img.thumbnail(resolution, Image.Resampling.LANCZOS)
                buf = io.BytesIO()
                img.save(buf, format='JPEG', quality=30)
                img_part._blob = buf.getvalue()
                changed += 1
            except Exception:
                continue

    await safe_edit_message(progress_msg, "üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞...")
    base, ext = os.path.splitext(filename)
    out_path = os.path.join(tempfile.gettempdir(), f"{base}_compressed{ext}")
    doc.save(out_path)
    
    await progress_msg.delete()
    last_message_text.pop(progress_msg.id, None)
    await client.send_file(user_id, out_path, caption=f"‚úÖ –ì–æ—Ç–æ–≤–æ: —Å–∂–∞—Ç–æ {changed}, —É–¥–∞–ª–µ–Ω–æ {deleted}")
    os.remove(filepath)
    os.remove(out_path)

# EPUB —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º
async def process_epub_compression(event, user_id, filename, filepath, resolution):
    book = epub.read_epub(filepath)
    changed = deleted = 0
    images = [item for item in list(book.get_items()) if item.media_type and item.media_type.startswith("image/")]
    total = len(images)
    
    if total == 0:
        await event.edit("–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ EPUB.")
        return

    progress_msg = await event.respond(f"üñºÔ∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π EPUB...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
    last_percent = 0

    for current, item in enumerate(images, 1):
        if should_update_progress(current, total, last_percent):
            progress_bar = create_progress_bar(current, total)
            action = "–£–¥–∞–ª–µ–Ω–∏–µ" if resolution is None else "–°–∂–∞—Ç–∏–µ"
            new_text = f"üñºÔ∏è {action} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π EPUB...\n{progress_bar}"
            await safe_edit_message(progress_msg, new_text)
            last_percent = int((current / total) * 100)

        if resolution is None:
            book.items.remove(item)
            deleted += 1
        else:
            try:
                img = Image.open(io.BytesIO(item.content)).convert("RGB")
                img.thumbnail(resolution, Image.Resampling.LANCZOS)
                buf = io.BytesIO()
                img.save(buf, format="JPEG", quality=30)
                item.content = buf.getvalue()
                item.media_type = "image/jpeg"
                changed += 1
            except Exception:
                continue

    await safe_edit_message(progress_msg, "üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ EPUB...")
    base, ext = os.path.splitext(filename)
    out_path = os.path.join(tempfile.gettempdir(), f"{base}_compressed{ext}")
    epub.write_epub(out_path, book)
    
    await progress_msg.delete()
    last_message_text.pop(progress_msg.id, None)
    await client.send_file(user_id, out_path, caption=f"‚úÖ –ì–æ—Ç–æ–≤–æ: —Å–∂–∞—Ç–æ {changed}, —É–¥–∞–ª–µ–Ω–æ {deleted}")
    os.remove(filepath)
    os.remove(out_path)

# EPUB: –≥–ª–∞–≤—ã —Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–æ–º
async def extract_chapters_from_epub_async(epub_path, event):
    temp_dir = tempfile.mkdtemp()
    html_blocks = []
    images = {}

    progress_msg = await event.respond("üìñ –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∏–∑ EPUB...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
    
    with zipfile.ZipFile(epub_path, 'r') as zf:
        zf.extractall(temp_dir)

    await safe_edit_message(progress_msg, "üìñ –ê–Ω–∞–ª–∏–∑ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ...\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 25%")
    
    all_files = []
    for root, _, files in os.walk(temp_dir):
        for file in files:
            all_files.append(os.path.join(root, file))
    
    processed = 0
    total_files = len(all_files)
    
    for file_path in all_files:
        file = os.path.basename(file_path)
        if file.lower().endswith((".xhtml", ".html", ".htm")):
            with open(file_path, "r", encoding="utf-8") as f:
                html_blocks.append(BeautifulSoup(f, "lxml"))
        elif file.lower().endswith((".jpg", ".jpeg", ".png", ".gif", ".svg", ".webp")):
            images[file] = file_path
        
        processed += 1
        if processed % 10 == 0:  # –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–∂–¥—ã–µ 10 —Ñ–∞–π–ª–æ–≤
            progress = int((processed / total_files) * 25) + 25
            progress_bar = "‚ñì" * (progress // 5) + "‚ñë" * (20 - progress // 5)
            new_text = f"üìñ –ê–Ω–∞–ª–∏–∑ —Ñ–∞–π–ª–æ–≤...\n{progress_bar} {progress}%"
            await safe_edit_message(progress_msg, new_text)

    await safe_edit_message(progress_msg, "üîç –ü–æ–∏—Å–∫ –≥–ª–∞–≤...\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 50%")
    
    chapters = []
    title, content, num = None, "", 0
    
    processed_blocks = 0
    total_blocks = len(html_blocks)
    
    for soup in html_blocks:
        if not soup.body:
            continue
        for elem in soup.body.find_all(recursive=False):
            text = elem.get_text(strip=True)
            match = CHAPTER_RE.match(text or "")
            if match:
                if title:
                    chapters.append((num, title, content.strip()))
                title = match.group(1)
                num_match = re.search(r'\d+', title)
                num = int(num_match.group()) if num_match else 0
                content = f"<h1>{title}</h1>"
            else:
                content += str(elem)
        
        processed_blocks += 1
        if processed_blocks % 5 == 0:  # –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–∂–¥—ã–µ 5 –±–ª–æ–∫–æ–≤
            progress = 50 + int((processed_blocks / total_blocks) * 25)
            progress_bar = "‚ñì" * (progress // 5) + "‚ñë" * (20 - progress // 5)
            new_text = f"üîç –ü–æ–∏—Å–∫ –≥–ª–∞–≤...\n{progress_bar} {progress}%"
            await safe_edit_message(progress_msg, new_text)
    
    if title:
        chapters.append((num, title, content.strip()))

    await safe_edit_message(progress_msg, "üîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤...\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë 75%")
    
    seen, result = set(), []
    for n, t, c in sorted(chapters, key=lambda x: x[0]):
        if t not in seen:
            result.append((n, t, c))
            seen.add(t)
    
    await safe_edit_message(progress_msg, f"‚úÖ –ù–∞–π–¥–µ–Ω–æ –≥–ª–∞–≤: {len(result)}\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì 100%")
    await asyncio.sleep(1)
    await progress_msg.delete()
    last_message_text.pop(progress_msg.id, None)
    
    return result, images

async def build_epub_async(title, chapters, image_paths, output_path, progress_msg):
    book = epub.EpubBook()
    book.set_identifier("converted")
    book.set_title(title)
    book.set_language("ru")
    book.add_author("Chronos Bot")

    spine = ['nav']
    toc = []
    
    total_steps = len(image_paths) + len(chapters) + 3  # +3 –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö —à–∞–≥–æ–≤
    current_step = 0

    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    for fname, path in image_paths.items():
        current_step += 1
        progress_bar = create_progress_bar(current_step, total_steps)
        new_text = f"üìö –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π...\n{progress_bar}"
        await safe_edit_message(progress_msg, new_text)
        
        ext = os.path.splitext(fname)[1][1:].lower()
        mime = f"image/{'jpeg' if ext in ['jpg', 'jpeg'] else ext}"
        with open(path, 'rb') as f:
            book.add_item(epub.EpubItem(uid=fname, file_name=f"images/{fname}", media_type=mime, content=f.read()))

    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥–ª–∞–≤
    for i, (num, chapter_title, html_body) in enumerate(chapters, 1):
        current_step += 1
        progress_bar = create_progress_bar(current_step, total_steps)
        new_text = f"üìö –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥–ª–∞–≤...\n{progress_bar}"
        await safe_edit_message(progress_msg, new_text)
        
        html = epub.EpubHtml(title=chapter_title, file_name=f"chap_{i}.xhtml", lang='ru')
        html.content = html_body
        book.add_item(html)
        spine.append(html)
        toc.append(epub.Link(html.file_name, chapter_title, f"chap_{i}"))

    # –§–∏–Ω–∞–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞
    current_step += 1
    progress_bar = create_progress_bar(current_step, total_steps)
    await safe_edit_message(progress_msg, f"üìö –°–æ–∑–¥–∞–Ω–∏–µ –æ–≥–ª–∞–≤–ª–µ–Ω–∏—è...\n{progress_bar}")
    
    book.spine = spine
    book.toc = toc
    book.add_item(epub.EpubNcx())
    book.add_item(epub.EpubNav())
    
    current_step += 1
    progress_bar = create_progress_bar(current_step, total_steps)
    await safe_edit_message(progress_msg, f"üìö –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ EPUB...\n{progress_bar}")

    epub.write_epub(output_path, book)
    
    current_step += 1
    progress_bar = create_progress_bar(current_step, total_steps)
    await safe_edit_message(progress_msg, f"üìö –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ...\n{progress_bar}")

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≥–ª–∞–≤ –∏–∑ FB2
async def extract_chapters_from_fb2_async(fb2_path, event):
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –≥–ª–∞–≤—ã –∏–∑ FB2 —Ñ–∞–π–ª–∞"""
    progress_msg = await event.respond("üìñ –ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã FB2...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
    
    ns = {'fb2': 'http://www.gribuser.ru/xml/fictionbook/2.0'}
    tree = etree.parse(fb2_path)
    root = tree.getroot()
    
    await safe_edit_message(progress_msg, "üìñ –ü–æ–∏—Å–∫ –≥–ª–∞–≤ –≤ FB2...\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 25%")
    
    chapters = []
    # –ò—â–µ–º –≤—Å–µ —Å–µ–∫—Ü–∏–∏ —Å –∑–∞–≥–æ–ª–æ–≤–∫–∞–º–∏
    sections = root.xpath('//fb2:section[fb2:title]', namespaces=ns)
    total = len(sections)
    
    for idx, section in enumerate(sections):
        if idx % 5 == 0:
            progress = 25 + int((idx / total) * 50)
            progress_bar = "‚ñì" * (progress // 5) + "‚ñë" * (20 - progress // 5)
            await safe_edit_message(progress_msg, f"üìñ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–µ–∫—Ü–∏–π...\n{progress_bar} {progress}%")
        
        # –ü–æ–ª—É—á–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
        title_elem = section.find('.//fb2:title', namespaces=ns)
        if title_elem is not None:
            title_text = ' '.join(title_elem.itertext()).strip()
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ª–∏ –∑–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞—Ç—Ç–µ—Ä–Ω—É –≥–ª–∞–≤—ã
            if CHAPTER_RE.search(title_text):
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å–µ–∫—Ü–∏–∏
                content = etree.tostring(section, encoding='unicode', pretty_print=True)
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–æ–º–µ—Ä –≥–ª–∞–≤—ã –µ—Å–ª–∏ –µ—Å—Ç—å
                num_match = re.search(r'\d+', title_text)
                num = int(num_match.group()) if num_match else len(chapters)
                
                chapters.append((num, title_text, content))
    
    await safe_edit_message(progress_msg, f"‚úÖ –ù–∞–π–¥–µ–Ω–æ –≥–ª–∞–≤: {len(chapters)}\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì 100%")
    await asyncio.sleep(1)
    await progress_msg.delete()
    last_message_text.pop(progress_msg.id, None)
    
    return chapters

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è FB2 —Å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º
async def build_fb2_with_toc_async(title, chapters, output_path, progress_msg):
    """–°–æ–∑–¥–∞–µ—Ç FB2 —Ñ–∞–π–ª —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º"""
    ns = {'fb2': 'http://www.gribuser.ru/xml/fictionbook/2.0'}
    
    # –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É FB2
    root = etree.Element('{http://www.gribuser.ru/xml/fictionbook/2.0}FictionBook', nsmap={'fb2': ns['fb2']})
    
    # –û–ø–∏—Å–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞
    description = etree.SubElement(root, '{http://www.gribuser.ru/xml/fictionbook/2.0}description')
    title_info = etree.SubElement(description, '{http://www.gribuser.ru/xml/fictionbook/2.0}title-info')
    book_title = etree.SubElement(title_info, '{http://www.gribuser.ru/xml/fictionbook/2.0}book-title')
    book_title.text = title
    
    # –¢–µ–ª–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞
    body = etree.SubElement(root, '{http://www.gribuser.ru/xml/fictionbook/2.0}body')
    
    total = len(chapters)
    
    # –î–æ–±–∞–≤–ª—è–µ–º –≥–ª–∞–≤—ã
    for idx, (num, chapter_title, content) in enumerate(chapters):
        progress = int((idx / total) * 100)
        progress_bar = create_progress_bar(idx, total)
        await safe_edit_message(progress_msg, f"üìö –°–±–æ—Ä–∫–∞ FB2...\n{progress_bar}")
        
        # –ü–∞—Ä—Å–∏–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≥–ª–∞–≤—ã
        try:
            section = etree.fromstring(content)
            body.append(section)
        except:
            # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Å–µ–∫—Ü–∏—é
            section = etree.SubElement(body, '{http://www.gribuser.ru/xml/fictionbook/2.0}section')
            section_title = etree.SubElement(section, '{http://www.gribuser.ru/xml/fictionbook/2.0}title')
            p = etree.SubElement(section_title, '{http://www.gribuser.ru/xml/fictionbook/2.0}p')
            p.text = chapter_title
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
    await safe_edit_message(progress_msg, "üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ FB2...\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì 100%")
    tree = etree.ElementTree(root)
    tree.write(output_path, encoding='utf-8', xml_declaration=True, pretty_print=True)

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –≥–ª–∞–≤ –∏–∑ DOCX
async def extract_chapters_from_docx_async(docx_path, event):
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –≥–ª–∞–≤—ã –∏–∑ DOCX —Ñ–∞–π–ª–∞ –ø–æ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º"""
    progress_msg = await event.respond("üìñ –ê–Ω–∞–ª–∏–∑ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã DOCX...\n‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 0%")
    
    doc = Document(docx_path)
    chapters = []
    current_chapter = None
    current_content = []
    
    total = len(doc.paragraphs)
    
    for idx, para in enumerate(doc.paragraphs):
        if idx % 20 == 0:
            progress = int((idx / total) * 75)
            progress_bar = create_progress_bar(idx, total)
            await safe_edit_message(progress_msg, f"üìñ –ê–Ω–∞–ª–∏–∑ –ø–∞—Ä–∞–≥—Ä–∞—Ñ–æ–≤...\n{progress_bar}")
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–∞—Ä–∞–≥—Ä–∞—Ñ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º –≥–ª–∞–≤—ã
        if para.style.name.startswith('Heading') or CHAPTER_RE.search(para.text):
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â—É—é –≥–ª–∞–≤—É
            if current_chapter:
                num_match = re.search(r'\d+', current_chapter)
                num = int(num_match.group()) if num_match else len(chapters)
                chapters.append((num, current_chapter, '\n'.join(current_content)))
            
            # –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é –≥–ª–∞–≤—É
            current_chapter = para.text.strip()
            current_content = [para.text]
        elif current_chapter:
            # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫ —Ç–µ–∫—É—â–µ–π –≥–ª–∞–≤–µ
            current_content.append(para.text)
    
    # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –≥–ª–∞–≤—É
    if current_chapter:
        num_match = re.search(r'\d+', current_chapter)
        num = int(num_match.group()) if num_match else len(chapters)
        chapters.append((num, current_chapter, '\n'.join(current_content)))
    
    await safe_edit_message(progress_msg, f"‚úÖ –ù–∞–π–¥–µ–Ω–æ –≥–ª–∞–≤: {len(chapters)}\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì 100%")
    await asyncio.sleep(1)
    await progress_msg.delete()
    last_message_text.pop(progress_msg.id, None)
    
    return chapters

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è DOCX —Å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º
async def build_docx_with_toc_async(title, chapters, output_path, progress_msg):
    """–°–æ–∑–¥–∞–µ—Ç DOCX —Ñ–∞–π–ª —Å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ–º"""
    doc = Document()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞
    doc.add_heading(title, 0)
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ
    doc.add_heading('–û–≥–ª–∞–≤–ª–µ–Ω–∏–µ', 1)
    
    total_steps = len(chapters) * 2 + 2
    current_step = 0
    
    # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –≥–ª–∞–≤ –¥–ª—è –æ–≥–ª–∞–≤–ª–µ–Ω–∏—è
    for num, chapter_title, _ in sorted(chapters, key=lambda x: x[0]):
        current_step += 1
        progress_bar = create_progress_bar(current_step, total_steps)
        await safe_edit_message(progress_msg, f"üìö –°–æ–∑–¥–∞–Ω–∏–µ –æ–≥–ª–∞–≤–ª–µ–Ω–∏—è...\n{progress_bar}")
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø—É–Ω–∫—Ç –æ–≥–ª–∞–≤–ª–µ–Ω–∏—è
        p = doc.add_paragraph(style='List Number')
        p.add_run(f"{chapter_title}")
    
    # –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø–æ—Å–ª–µ –æ–≥–ª–∞–≤–ª–µ–Ω–∏—è
    doc.add_page_break()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –≥–ª–∞–≤—ã
    for num, chapter_title, content in sorted(chapters, key=lambda x: x[0]):
        current_step += 1
        progress_bar = create_progress_bar(current_step, total_steps)
        await safe_edit_message(progress_msg, f"üìö –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥–ª–∞–≤...\n{progress_bar}")
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≥–ª–∞–≤—ã
        doc.add_heading(chapter_title, 1)
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –≥–ª–∞–≤—ã
        for paragraph in content.split('\n'):
            if paragraph.strip():
                doc.add_paragraph(paragraph)
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞–∑—Ä—ã–≤ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø–æ—Å–ª–µ –≥–ª–∞–≤—ã
        doc.add_page_break()
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–æ–∫—É–º–µ–Ω—Ç
    current_step += 1
    progress_bar = create_progress_bar(current_step, total_steps)
    await safe_edit_message(progress_msg, f"üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ DOCX...\n{progress_bar}")
    
    doc.save(output_path)

# –ó–∞–ø—É—Å–∫
client.start()
print("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω.")
client.run_until_disconnected()
